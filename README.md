# FreeRTOS_Tasks_Communication
4 tasks communicating via fixed size queue, 3 sender tasks sending messages to queue and one receiver task receiving messages from the queue, all the tasks are blocked waiting for a dedicated semaphore for each task that is relased by each task's timer, the 3 sender tasks timers periods is generated randomly on every call back but the random value is bounded we have 6 upper and lower bounds that the code iterates over, and the receiver task has a fixed period of 100ms, the code prints the statistics of the sent messages, blocked messages and received messages for every task in each iteration and the program is terminated when all the 6 iterations are finsished.
# How the Program Works?
In this program we are using (FreeRTOS) operating system, we have 3 sender tasks and one receiver task, each task has its own timer and semaphore, we created a function to generate a random number with in certain bounds to be used as timer period for each sender’s timer, when the sender timer expires it executes the call back function which includes generating a new random value to be used as the timer’s next period and then using the function (xTimerChangePeriod) to change the timer’s period and finally release the dedicated semaphore that the task is waiting on, the sender tasks sends the message to the queue if there is space available, if this operation is successful a dedicated counter will be incremented and if this operation fails another counter will be incremented, the receiver task receives messages from queue, if this operation is successful a dedicated counter for received messages will be incremented. The receiver task timer has a constant period, when it expires it executes the call back function, this call back function includes giving the dedicated semaphore that the receiver task is waiting on to execute and check if the current received messages has reached 1000, if this condition is satisfied it prints the statistics of all the 3 tasks and resets all global variables, in the created reset function it’s self we count the iterations, if the iteration counter is greater than 5, meaning that all the required bounds have been iterated over, “Game Over” is printed and the program stops execution, note that the iteration counter is also used to access the constant arrays that include the upper and lower bounds of the required times, in the main function we create the required tasks, semaphores and timers and queue we give the sender timers an initial random value that will be changed after each timer call back function, and finally we start the scheduler. 
